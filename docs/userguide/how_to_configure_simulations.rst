How-to use model transformations and evaluation modes to configure simulations
==============================================================================

Qiskit Dynamics provides various configuration options when setting up
simulations that go beyond setting ODE solver options. Here we walk
through some of these options, demonstrating how to use them and their
potential benefits.

This guide covers the topics:

1. How-to set up a simulation in a rotating frame, and its potential
   benefits.
2. How-to perform a rotating wave approximation, and its potential
   benefits.
3. How-to use a sparse evaluation mode, and how-to appropriately set a
   rotating frame to preserve sparsity.

Throughout this guide we work at the level of the ``Solver`` interface,
and consider Hamiltonian dynamics for simplicity, however all of the
considerations have their analogs for Lindblad dynamics.

1. How-to set up a simulation in a rotating frame, and its potential benefits.
==============================================================================

“Entering a rotating frame” is a mathematical transformation on linear
matrix differential equations that results in another equivalent
equation of the same structure but with different properties (see the
:ref:``Rotating frames section of the Models API documentation <Rotating frames>``
for details).

Here we show how to automatically enter a rotating frame via an optional
argument when initializing a ``Solver`` instance, and demonstrate how a
well-chosen :math:`H_0` can impact the behaviour of ODE solvers.

We will simulate the unitary generated by a transmon model with
Hamiltonian:

.. math:: H(t) = 2 \pi \nu N + \pi \alpha N(N-I) + s(t) \times 2 \pi r (a + a^\dagger)

where - :math:`N`, :math:`a`, and :math:`a^\dagger` are, respectively,
the number, annihilation, and creation operators. - :math:`\nu` is the
qubit frequncy and :math:`r` is the drive strength. - :math:`s(t)` is
the drive signal, which we will take to be on resonance with constant
envelope :math:`1`.

We will first construct the components of the model, then solve the
model both as specified, as well as in the rotating frame of the static
component, then compare both the solving time and final results.

.. code:: ipython3

    import numpy as np
    from qiskit.quantum_info import Operator
    from qiskit_dynamics import Solver, Signal
    
    dim = 5
    
    v = 5.
    anharm = -0.33
    r = 0.1
    
    a = np.diag(np.sqrt(np.arange(1, dim)), 1)
    adag = np.diag(np.sqrt(np.arange(1, dim)), -1)
    N = np.diag(np.arange(dim))
    
    # static part
    static_hamiltonian = 2 * np.pi * v * N + np.pi * anharm * N * (N - np.eye(dim))
    # drive term
    drive_hamiltonian = 2 * np.pi * r * (a + adag)
    # drive signal
    drive_signal = Signal(1., carrier_freq=v)
    
    # total simulation time
    T = 1. / r

First, construct a solver without entering a rotating frame, and solve.

.. code:: ipython3

    solver = Solver(static_hamiltonian=static_hamiltonian,
                    hamiltonian_operators=[drive_hamiltonian],
                    hamiltonian_signals=[drive_signal])
    
    y0 = np.eye(dim, dtype=complex)
    %time results = solver.solve(t_span=[0., T], y0=y0, atol=1e-10, rtol=1e-10)


.. parsed-literal::

    CPU times: user 6.58 s, sys: 24 ms, total: 6.6 s
    Wall time: 6.6 s


Next, define a ``Solver`` in the rotating frame of the static
Hamiltonian by setting the ``rotating_frame`` kwarg, and solve.

.. code:: ipython3

    rf_solver = Solver(static_hamiltonian=static_hamiltonian,
                          hamiltonian_operators=[drive_hamiltonian],
                          hamiltonian_signals=[drive_signal],
                          rotating_frame=static_hamiltonian)
    
    y0 = np.eye(dim, dtype=complex)
    %time rf_results = rf_solver.solve(t_span=[0., T], y0=y0, atol=1e-10, rtol=1e-10)


.. parsed-literal::

    CPU times: user 2.63 s, sys: 8.72 ms, total: 2.64 s
    Wall time: 2.63 s


Observe that despite being mathematically equivalent, the solver takes
less time to solve when in the rotating frame.

Next, we verify that the results are numerically equivalent. As the
solvers solved the same model in different frames, we need to transform
the final results to the same frame before comparing, via utility
functions in the ``RotatingFrame`` instance stored within the model in
``Solve.model.rotating_frame``.

To compare the results, we use the fidelity function for unitaries:

.. math:: f(U, V) = \frac{|Tr(U^\dagger V)|^2}{d^2},

where :math:`d` is the dimension.

.. code:: ipython3

    def fidelity(U, V):
        # the fidelity function
        inner_product = (U.conj() * V).sum()
        return (np.abs(inner_product) / dim) ** 2
    
    U = results.y[-1]
    # transform the results of the solver in the rotating frame out of the rotating frame
    U_rf = rf_solver.model.rotating_frame.state_out_of_frame(T, rf_results.y[-1])
    
    fidelity(U, U_rf)




.. parsed-literal::

    0.9999999944421281



Based on the fidelity, as expected, we see that the two simulations
produce the same result with reasonable accuracy based on our specified
tolerances.

Despite their mathematical equivalence, the discrepancy in solving times
can be understood by examining the number of RHS evaluations used by the
solver in each instance:

.. code:: ipython3

    print('Number of RHS evaluations with no rotating frame: {}'.format(results.nfev))
    print('Number of RHS evaluations in rotating frame: {}'.format(rf_results.nfev))


.. parsed-literal::

    Number of RHS evaluations with no rotating frame: 32366
    Number of RHS evaluations in rotating frame: 8246


Entering this particular rotating frame has the effect of simplifying
the evolution, thereby requiring less RHS evaluations, and ultimately
speeding up solver execution time.

2. How-to perform a rotating wave approximation, and its potential benefits.
----------------------------------------------------------------------------

See the API documentation for the
:meth:``~qiskit_dynamics.models.rotating_wave_approximation`` function
for specific details about the rotating wave approximation (RWA). For
the purposes of this guide, we demonstrate how the RWA can be
automatically applied by setting an additional optional argument
``rwa_cutoff_freq`` to the ``Solver`` intialization.

.. code:: ipython3

    rwa_solver = Solver(static_hamiltonian=static_hamiltonian,
                        hamiltonian_operators=[drive_hamiltonian],
                        hamiltonian_signals=[drive_signal],
                        rotating_frame=static_hamiltonian,
                        rwa_cutoff_freq=1.5 * v)
    
    y0 = np.eye(dim, dtype=complex)
    %time rwa_results = rwa_solver.solve(t_span=[0., T], y0=y0, atol=1e-10, rtol=1e-10)


.. parsed-literal::

    CPU times: user 516 ms, sys: 3.17 ms, total: 520 ms
    Wall time: 519 ms


We observe a further reduction in time, as a result of even fewer RHS
evaluations:

.. code:: ipython3

    print('Number of RHS evaluations in rotating frame with RWA: {}'.format(rwa_results.nfev))


.. parsed-literal::

    Number of RHS evaluations in rotating frame with RWA: 1274


This speed comes at the cost of lower accuracy. Unlike entering a
rotating frame, the RWA is an approximation, and thus produces a
solution that is close, but not mathematically equivalent to the
original:

.. code:: ipython3

    U_rwa = rwa_solver.model.rotating_frame.state_out_of_frame(T, rwa_results.y[-1])
    
    fidelity(U_rwa, U)




.. parsed-literal::

    0.9986750508422463



3. How-to use a sparse evaluation mode, and how-to appropriately set a rotating frame to preserve sparsity.
===========================================================================================================

Beyond setting frames or the RWA, models and solvers can be further
configured by specifying an ``evaluation_mode``. See the
:ref:``evaluation modes section of the Models API documentation <evaluation modes>``
for a general description. Here we show how to use the sparse evaluation
mode, and in particular highlight that, when using a sparse evaluation
mode, care must be taken to only enter rotating frames the preserve
sparsity of the underlying data.

For the example here we set JAX to be the default array backend, which
is more performant. See the
:ref:``userguide on using JAX <how-to use jax>`` for a more detailed
explanation of how to work with JAX in Qiskit Dynamics. An important
note is that sparse arrays are only recommended for use on CPU.

Start off by configuring to use JAX.

.. code:: ipython3

    from qiskit_dynamics.dispatch import Array
    
    # configure jax to use 64 bit mode
    import jax
    jax.config.update("jax_enable_x64", True)
    
    # tell JAX we are using CPU
    jax.config.update('jax_platform_name', 'cpu')
    
    # import dispatch and set default backend
    from qiskit_dynamics import dispatch
    dispatch.set_default_backend('jax')

Reconstruct the model pieces at a much larger dimension, to observe the
benefits of using sparse arrays. Furthermore, for this example, we will
simulate a single initial state, rather than the full unitary, which
further highlights the benefits of the sparse representation.

.. code:: ipython3

    dim = 300
    
    v = 5.
    anharm = -0.33
    r = 0.02
    
    a = np.diag(np.sqrt(np.arange(1, dim, dtype=complex)), 1)
    adag = np.diag(np.sqrt(np.arange(1, dim, dtype=complex)), -1)
    N = np.diag(np.arange(dim, dtype=complex))
    
    static_hamiltonian = 2 * np.pi * v * N + np.pi * anharm * N * (N - np.eye(dim))
    drive_hamiltonian = 2 * np.pi * r * (a + adag)
    drive_signal = Signal(Array(1.), carrier_freq=v)
    
    y0 = np.zeros(dim, dtype=complex)
    y0[1] = 1.
    
    T = 1 / r

Construct standard dense solver in the rotating frame of the static
Hamiltonian.

.. code:: ipython3

    solver = Solver(static_hamiltonian=static_hamiltonian,
                           hamiltonian_operators=[drive_hamiltonian],
                           hamiltonian_signals=[drive_signal],
                           rotating_frame=static_hamiltonian)

Construct sparse solver in the frame of the diagonal of the static
Hamiltonian. Note that in this case the static Hamiltonian is already
diagonal, but we explicitly highlight the need for this.

.. code:: ipython3

    sparse_solver = Solver(static_hamiltonian=static_hamiltonian,
                           hamiltonian_operators=[drive_hamiltonian],
                           hamiltonian_signals=[drive_signal],
                           rotating_frame=np.diag(static_hamiltonian),
                           evaluation_mode='sparse')

Next, we define functions for evaluating the final state as a function
of the drive amplitude. We will just-in-time compile these. (See the
:ref:``userguide on using JAX <how-to use jax>`` for a more detailed
discussion on just-in-time copmilation of Qiskit Dynamics code.)

.. code:: ipython3

    def solver_func(amp):
        drive_signal = Signal(Array(amp), carrier_freq=v)
        solver_copy = solver.copy()
        solver_copy.signals = [drive_signal]
        res = solver_copy.solve(t_span=[0., T], y0=y0, method='jax_odeint', atol=1e-10, rtol=1e-10)
        return res.y[-1]
    
    def sparse_solver_func(amp):
        drive_signal = Signal(Array(amp), carrier_freq=v)
        solver_copy = sparse_solver.copy()
        solver_copy.signals = [drive_signal]
        res = solver_copy.solve(t_span=[0., T], y0=y0, method='jax_odeint', atol=1e-10, rtol=1e-10)
        return res.y[-1]

Just-in-time compile them.

.. code:: ipython3

    jitted_solver_func = jax.jit(solver_func)
    jitted_sparse_solver_func = jax.jit(sparse_solver_func)

Run the dense simulation once.

.. code:: ipython3

    %time yf = jitted_solver_func(1.).block_until_ready()


.. parsed-literal::

    CPU times: user 4.86 s, sys: 28.2 ms, total: 4.89 s
    Wall time: 4.89 s


Run it again to see the true compiled speed.

.. code:: ipython3

    %time yf = jitted_solver_func(1.).block_until_ready()


.. parsed-literal::

    CPU times: user 2.69 s, sys: 6.42 ms, total: 2.69 s
    Wall time: 2.69 s


Run the sparse solver once.

.. code:: ipython3

    %time yf_sparse = jitted_sparse_solver_func(1.).block_until_ready()


.. parsed-literal::

    CPU times: user 3.71 s, sys: 24 ms, total: 3.73 s
    Wall time: 3.73 s


Run it again to see the true compiled speed.

.. code:: ipython3

    %time yf_sparse = jitted_sparse_solver_func(1.).block_until_ready()


.. parsed-literal::

    CPU times: user 1.15 s, sys: 2.83 ms, total: 1.15 s
    Wall time: 1.15 s


Verify equality of the results in a common frame.

.. code:: ipython3

    yf = solver.model.rotating_frame.state_out_of_frame(T, yf)
    yf_sparse = sparse_solver.model.rotating_frame.state_out_of_frame(T, yf_sparse)
    
    np.linalg.norm(yf - yf_sparse)




.. parsed-literal::

    Array(3.48335145e-13)



We observe that the final states are extremely close, and that the
sparse representation executes more quickly for this problem.

